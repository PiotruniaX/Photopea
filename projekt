import cv2
import numpy as np
import matplotlib.pyplot as plt
from tkinter import *
from PIL import Image, ImageTk
import os

# === Przygotowanie obrazów ===
DOCELNY_ROZMIAR = (360, 240)  # możesz zmienić na dowolne (width, height)

def load_and_resize(path, size):
    img = cv2.imread(path)
    if img is None:
        raise FileNotFoundError(f'Brak pliku: {path}')
    return cv2.resize(img, size, interpolation=cv2.INTER_AREA)

# --- Wczytanie i przeskalowanie obu obrazów ---
img = load_and_resize('image1.jpg', DOCELNY_ROZMIAR)
img2 = load_and_resize('image2.jpg', DOCELNY_ROZMIAR)

results = []

def add_result(name, image):
    """Helper to store result frames"""
    results.append((name, image))

# 1. Transformacje liniowe
add_result('Bright', cv2.convertScaleAbs(img, alpha=1.5, beta=30))
add_result('Dark', cv2.convertScaleAbs(img, alpha=0.5, beta=0))
add_result('Negative', 255 - img)

# 2. Transformacja potęgowa – rozjaśnianie (gamma<1) i przyciemnianie (gamma>1)
gamma_values = [0.5, 2.2]
for g in gamma_values:
    lut = np.array([(i/255.0)**(1/g)*255 for i in range(256)], dtype=np.uint8)
    gamma_img = cv2.LUT(img, lut)
    add_result(f'Gamma {g}', gamma_img)

# 3. Mieszanie dwóch obrazów – 16 algorytmów
# --- Przygotowanie obrazów jako float32 w [0..1] ---
img_f  = img.astype(np.float32) / 255.0
img2_f = img2.astype(np.float32) / 255.0

# --- Definicja 16 trybów mieszania ---
blend_ops = [
    ('Suma',lambda a, b: np.clip(a + b, 0, 1)),                                   # Additive
    ('Odejmowanie',lambda a, b: np.clip(a + b - 1, 0, 1)),                               # Subtractive
    ('Różnica',lambda a, b: np.abs(a - b)),                                         # Difference
    ('Mnożenie',lambda a, b: a * b),                                                # Multiply
    ('Mnożenie odwrotności', lambda a, b: 1 - (1 - a) * (1 - b)),                           # Screen
    ('Negacja',lambda a, b: 1 - np.abs(1 - a - b)),                                 # Negation
    ('Ciemniejsze',lambda a, b: np.minimum(a, b)),                                       # Darken
    ('Jaśniejsze',lambda a, b: np.maximum(a, b)),                                       # Lighten
    ('Wyłączenie',lambda a, b: a + b - 2 * a * b),                                     # Exclusion
    ('Nakładka',lambda a, b: np.where(                                              # Overlay
                         a < 0.5,
                         2 * a * b,
                         1 - 2 * (1 - a) * (1 - b)
                     )),
    ('Ostre światło',  lambda a, b: np.where(                                              # Hard light
                         b < 0.5,
                         2 * a * b,
                         1 - 2 * (1 - a) * (1 - b)
                     )),
    ('Łagodne światło',lambda a, b: np.where(                                              # Soft light
                         b < 0.5,
                         2 * a * b + a * a * (1 - 2 * b),
                         np.sqrt(a) * (2 * b - 1) + 2 * a * (1 - b)
                     )),
    ('Rozcieńczenie',  lambda a, b: np.where(                                              # Color dodge
                         b < 1.0,
                         np.clip(a / (1 - b), 0, 1),
                         1.0
                     )),
    ('Wypalanie',      lambda a, b: np.where(                                              # Color burn
                         b > 0.0,
                         1 - np.clip((1 - a) / b, 0, 1),
                         0.0
                     )),
    ('Odbicie',        lambda a, b: np.where(                                              # Reflect
                         b < 1.0,
                         np.clip(a * a / (1 - b), 0, 1),
                         1.0
                     )),
    ('Przezroczystość',lambda a, b, alpha=0.5: (1 - alpha) * b + alpha * a),                # Opacity
]

# --- Dodanie wyników do listy ---
for name, fn in blend_ops:
    if name == 'Przezroczystość':
        out_f = fn(img_f, img2_f, alpha=0.7)  # ustawienie α
    else:
        out_f = fn(img_f, img2_f)
    out_u8 = (np.clip(out_f, 0, 1) * 255).astype(np.uint8)
    add_result(f'Mieszanie: {name}', out_u8)


# 4. Modyfikacja kontrastu obrazu barwnego
def korekcja_kontrastu_v1(img, c):
    # img: uint8 [0..255], c: int w [-127..127]
    img_i = img.astype(np.int16)  # pozwala na wartości ujemne przy odejmowaniu c
    if c >= 0:
        # wzór a): v' = (127/(127-c))*(v - c)
        faktor = 127.0 / (127.0 - c)
    else:
        # wzór b): v' = ((127+c)/127)*(v - c)
        faktor = (127.0 + c) / 127.0
    out = faktor * (img_i - c)
    return np.clip(out, 0, 255).astype(np.uint8)

# przykładowe parametry c:
for c in (50, -50):
    wynik = korekcja_kontrastu_v1(img, c)
    nazwa = f'Kontrast c={c:+d}'
    add_result(nazwa, wynik)

# 5. Generowanie histogramu R, G, B

groups = cv2.split(img2)
colors = ('b','g','r')
plt.figure()
for ch, col in zip(groups, colors):
    hist = cv2.calcHist([ch],[0],None,[256],[0,256])
    plt.plot(hist, label=col)
plt.legend(); plt.title('Histogram RGB')
plt.savefig('hist.jpg')
plt.close()
hist_img = cv2.imread('hist.jpg')
hist_img = cv2.resize(hist_img, (img.shape[1], img.shape[0]))
os.remove('hist.jpg')
add_result('Histogram', hist_img)

# 6. Wyrównanie histogramu
img_wyr = cv2.cvtColor(img, cv2.COLOR_BGR2YUV)
img_wyr[:,:,0] = cv2.equalizeHist(img_wyr[:,:,0])
wyrownanie = cv2.cvtColor(img_wyr, cv2.COLOR_YUV2BGR)
add_result('Wyrównanie Histogramu', wyrownanie)

# 7. Skalowanie histogramu
normalized = cv2.normalize(img, None, 0,255, cv2.NORM_MINMAX)
add_result('Skalowanie Histogramu', normalized)

# 8. Filtr dolnoprzepustowy (Gaussian)
low = cv2.GaussianBlur(img, (5,5),0)
add_result('Dolnoprzepustowy', low)

# 9. Filtry górnoprzepustowe: Robertsa, Prewitta, Sobela, Laplace’a
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# Roberts
krx = np.array([[1,0],[0,-1]],dtype=np.float32)
kry = np.array([[0,1],[-1,0]],dtype=np.float32)
add_result('Roberts X', cv2.filter2D(gray,-1,krx))
add_result('Roberts Y', cv2.filter2D(gray,-1,kry))
# Prewitt
kpx = np.array([[1,0,-1],[1,0,-1],[1,0,-1]],dtype=np.float32)
kpy = kpx.T
add_result('Prewitt X', cv2.filter2D(gray,-1,kpx))
add_result('Prewitt Y', cv2.filter2D(img,-1,kpy))
# Sobel X/Y
add_result('Sobel X', cv2.convertScaleAbs(cv2.Sobel(img,cv2.CV_64F,1,0)))
add_result('Sobel Y', cv2.convertScaleAbs(cv2.Sobel(img,cv2.CV_64F,0,1)))
# Laplace – trzy maski
lap_masks = [
    np.array([[0,-1,0],[-1,4,-1],[0,-1,0]],dtype=np.float32),
    np.array([[-1,-1,-1],[-1,8,-1],[-1,-1,-1]],dtype=np.float32),
    np.array([[-2,1,-2],[1,4,1],[-2,1,-2]],dtype=np.float32)
]
for i,km in enumerate(lap_masks,1):
    add_result(f'Laplace {i}', cv2.filter2D(gray,-1,km))

# 10. Filtry statystyczne: min, max, medianowy
add_result('Min Filter', cv2.erode(img, np.ones((2,2),np.uint8)))
add_result('Max Filter', cv2.dilate(img, np.ones((2,2),np.uint8)))
add_result('Median Filter', cv2.medianBlur(img,5))

# === GUI ===
def cvimg_to_tk(img):
    if img.ndim==2:
        img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
    img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    return ImageTk.PhotoImage(Image.fromarray(img_rgb))

def show_result(title, image):
    tk_image = cvimg_to_tk(image)
    result_label.config(image=tk_image)
    result_label.image = tk_image
    result_title.config(text=title)

root = Tk()
root.title("Przetwarzanie obrazu")
root.geometry("1050x600")

# Główny podział na lewo (przyciski) i prawo (obrazy + wynik)
main_frame = Frame(root)
main_frame.pack(fill=BOTH, expand=True)

# Lewy panel - przyciski + scrollbar
left_frame = Frame(main_frame)
left_frame.pack(side=LEFT, fill=Y)

canvas = Canvas(left_frame, width=200)
scrollbar = Scrollbar(left_frame, orient=VERTICAL, command=canvas.yview)
canvas.configure(yscrollcommand=scrollbar.set)

scrollbar.pack(side=LEFT, fill=Y)
canvas.pack(side=LEFT, fill=Y, expand=True)

button_frame = Frame(canvas)
canvas.create_window((0, 0), window=button_frame, anchor='nw')

button_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

# Tutaj dodajemy przyciski
for title, output in results:
    Button(button_frame, text=title, width=25, command=lambda t=title, i=output: show_result(t, i)).pack(pady=2)

# Prawy panel - obrazy i wynik
right_frame = Frame(main_frame)
right_frame.pack(side=LEFT, fill=BOTH, expand=True)

# Obrazy obok siebie
top_images_frame = Frame(right_frame)
top_images_frame.pack(pady=10)

img1_tk = cvimg_to_tk(img)
img2_tk = cvimg_to_tk(img2)

img1_label = Label(top_images_frame)
img1_label.pack(side=LEFT, padx=10)
Label(top_images_frame, image=img1_tk).pack(side=LEFT, padx=10)

img2_label = Label(top_images_frame)
img2_label.pack(side=LEFT, padx=10)
Label(top_images_frame, image=img2_tk).pack(side=LEFT, padx=10)

# Wynik pod obrazkami
result_frame = Frame(right_frame)
result_frame.pack(pady=20)

result_title = Label(result_frame, font=("Arial", 14))
result_title.pack(pady=5)

result_label = Label(result_frame)
result_label.pack()

root.mainloop()
